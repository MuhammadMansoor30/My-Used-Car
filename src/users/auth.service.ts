import { BadRequestException, Injectable, NotFoundException } from "@nestjs/common";
import { UsersService } from "./users.service";
import { randomBytes, scrypt as _scrypt } from "crypto";
import { promisify } from "util";

const scrypt = promisify(_scrypt);

@Injectable()
export class AuthService{
    constructor(private userService: UsersService){}

    async signup(email: string, password: string){
        const user = await this.userService.find(email);
        if(user.length){
            throw new BadRequestException("Email In Use");
        }
        const salt = randomBytes(8).toString('hex');
        const hash = (await scrypt(password, salt, 32)) as Buffer;
        const hashedPassword = salt + '.' + hash.toString('hex');

        const newUser = await this.userService.create(email, hashedPassword);

        return newUser;
    }

    async signin(email: string, password: string){
        const [user] = await this.userService.find(email);  // Destructuring and getting single user with given email.
        if(!user){
            throw new NotFoundException("User not Found");
        }
        const [salt, storedHash] = user.password.split('.');  // Destructuring and getting salt and hash as stored during signup.
        const hash = (await scrypt(password, salt, 32)) as Buffer;
        
        if(storedHash !== hash.toString('hex')){
            throw new BadRequestException('Wrong Password Provided');
        }
        return user;
    }

}

// NOTES (SEC 11):
// Creating the auth service file and linking it with userService file to add authetication logic to our app.
// Adding Injectable() decorator at top to mark class as a provider class for DI to work and inject it to controller constructor.
// Now we will implement the password hasing feature to store user password in Db in hashed format.
// randomBytes function is used to generate random bytes of specific length in this case 8 and then we will convert it into string of hexadecimal. In hexadecimal each 1 bytes converts to 2 bytes so our salt will be of 16 bytes.
// Then we will hash the password using scrypt function by using the provided password and salt and then join the salt and hash after converting the hash to hexadecimal.
// Specifying the type of hash as Buffer so typescript doesnt make errors as return tyoe of scrypt is unknown.
// Here 32 is the number of bytes generated by the hashing the password. Can be any number of our choice.
// Joining is necessary so that we know the salt of each user and then decrypt the user password back again.
// The scrypt function return a callback function so we wrap it aeoung the promisify function to convert the callback to promise.
// Creating newUser using the userService create method and then returning it.
// Creating the signin functionality to first find a specific user using array destructuring.
// Then destructuring the stored password to get the salt and hash based on the join logic.
// Rehashing the provided user password to compare the hash of provided and stored passwords. If Match return user.